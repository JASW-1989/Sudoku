<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Goddess Defense v9.1 - Sanctuary Guardian</title>
    
    <!-- iOS PWA Settings -->
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/3421/3421111.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@500;700&family=Noto+Sans+TC:wght@500;900&display=swap" rel="stylesheet">
    
    <style>
        :root { --p: #ff66aa; --g: #ffd700; --b: #1b2014; --accent: #55efc4; }
        body { font-family: 'Quicksand', 'Noto Sans TC', sans-serif; background-color: #0f120d; margin: 0; overflow: hidden; color: #fff; }
        canvas { display: block; margin: 0 auto; background: #26381a; cursor: grab; box-shadow: 0 0 50px rgba(0,0,0,0.8); }
        canvas:active { cursor: grabbing; }
        
        .glass-gold { background: rgba(30, 40, 20, 0.95); backdrop-filter: blur(25px); border: 1px solid rgba(255, 215, 0, 0.2); }
        .unit-card { transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); border: 2px solid rgba(255,255,255,0.08); }
        .unit-card.active { border-color: var(--p); background: rgba(255, 102, 170, 0.25); transform: translateY(-12px); box-shadow: 0 15px 35px rgba(255, 102, 170, 0.4); }
        
        .main-btn { background: linear-gradient(135deg, var(--p), #d63384); color: white; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(214, 51, 132, 0.4); }
        .main-btn:active { transform: scale(0.92); }
        
        @keyframes floating { 0% { transform: translateY(0px); } 50% { transform: translateY(-10px); } 100% { transform: translateY(0px); } }
        .hero-float { animation: floating 3s ease-in-out infinite; }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        /** * --- SECTION 1: éŠæˆ²æ•¸æ“šé…ç½® --- */
        const GRID_SIZE = 50; 
        const CANVAS_WIDTH = 400;
        const CANVAS_HEIGHT = 750;

        const UNIT_DATA = {
            ARCHER: {
                id: "ARCHER", name: "éŠ€é«®çµäºº", icon: "ğŸ¹", cost: 100, range: 185, damage: 50, cooldown: 30, type: "R_PHYS",
                desc: "é ç¨‹ç‰©ç†ã€‚ç²¾æº–å°„æ“Šï¼Œæ¯ 5 æ¬¡æ”»æ“Šè§¸ç™¼ 3.5 å€å¼·æ•ˆçˆ†æ“Šã€‚",
                upgrades: [{ cost: 250, damage: 100, range: 210 }, { cost: 550, damage: 200, range: 260 }],
                evolutions: [
                    { id: "SNIPER", name: "ç¥å°„æ‰‹", icon: "ğŸ¯", cost: 1200, range: 500, damage: 600, cooldown: 80, desc: "å…¨åœ–ç‹™æ“Šï¼Œå°ˆé–€æ“Šç ´æ·±æ·µè»åœ˜é¦–é ˜ã€‚" },
                    { id: "WIND", name: "é¢¨è¡Œè€…", icon: "ğŸƒ", cost: 1200, range: 220, damage: 150, cooldown: 5, desc: "ç‰©ç†æ¥µé€Ÿé€£å°„ï¼Œç„¡äººèƒ½é€ƒè„«ã€‚"}
                ]
            },
            PRIEST: {
                id: "PRIEST", name: "ç¥è–ç‰§å¸«", icon: "ğŸ•Šï¸", cost: 300, range: 165, heal: 40, cooldown: 45, type: "R_HEAL",
                desc: "é ç¨‹è¼”åŠ©ã€‚è² è²¬ä¿®å¾©è¿‘æˆ°å–®ä½çš„å‚·å‹¢ï¼Œé˜²ç¦¦ç·šçš„å¾Œç›¾ã€‚",
                upgrades: [{ cost: 450, heal: 80, range: 185 }, { cost: 800, heal: 200, range: 220 }],
                evolutions: [
                    { id: "ANGEL", name: "ç†¾å¤©ä½¿", icon: "ğŸ˜‡", cost: 1500, range: 260, heal: 500, cooldown: 45, desc: "ç¥ä¹‹æ©å…¸ï¼Œç¬é–“æ¢å¾©å—å‚·éšŠå‹ã€‚" },
                    { id: "SAINT", name: "è–è€…", icon: "âœ¨", cost: 1500, range: 220, damage: 200, heal: 150, cooldown: 35, type: "R_HYBRID", desc: "é‚Šæ²»ç™‚é‚Šæ”»æ“Šã€‚"}
                ]
            },
            MAGE: {
                id: "MAGE", name: "ç´…è“®é­”å¥³", icon: "ğŸ§™", cost: 450, range: 140, damage: 110, cooldown: 85, color: "#ff8e8e", type: "R_MAGIC",
                desc: "é ç¨‹é­”æ³•ã€‚ç¯„åœçˆ†ç‚¸å‚·å®³ï¼Œç„¡è¦–é‡ç”²é˜²ç¦¦ã€‚",
                upgrades: [{ cost: 700, damage: 250, range: 160 }, { cost: 1200, damage: 500, range: 195 }],
                evolutions: [
                    { id: "ARCH", name: "å¤§è³¢è€…", icon: "ğŸ”¥", cost: 2000, range: 240, damage: 1200, cooldown: 110, isSplash: true, splashRadius: 130, desc: "éš•çŸ³æ ¸çˆ†ï¼Œé€ æˆæ¯€æ»…æ€§ç©¿é€å‚·å®³ã€‚" },
                    { id: "ICE", name: "å¯’å†°å§¬", icon: "â„ï¸", cost: 2000, range: 210, damage: 350, cooldown: 65, slow: 0.85, desc: "è¬ç‰©å‡çµï¼Œä½¿æ•µè»å¯¸æ­¥é›£è¡Œã€‚"}
                ]
            },
            VALKYRIE: {
                id: "VALKYRIE", name: "æˆ°ä¹™å¥³", icon: "âš”ï¸", cost: 900, range: 130, damage: 400, cooldown: 110, color: "#8eb5ff", type: "R_PHYS",
                desc: "ç²¾è‹±ç‰©æ”»ã€‚å–®é«”æœ€é«˜å‚·å®³ï¼Œå°ˆæ®ºé«˜é›£åº¦æ€ªç‰©ã€‚",
                upgrades: [{ cost: 1300, damage: 900, range: 150 }, { cost: 2200, damage: 2000, range: 180 }],
                evolutions: [
                    { id: "ODIN", name: "å¥§ä¸ä¹‹æ§", icon: "ğŸ”±", cost: 4000, range: 230, damage: 6000, cooldown: 120, desc: "æŠ•æ“²æ°¸æ†ä¹‹æ§ï¼Œé€ æˆçœŸå¯¦å‚·å®³ã€‚" },
                    { id: "WING", name: "ç¿¼ä¹‹åˆƒ", icon: "ğŸ•Šï¸", cost: 4000, range: 190, damage: 3500, cooldown: 65, desc: "æ¥µé€Ÿè¿‘æ¥æ–¬æ“Šã€‚"}
                ]
            },
            PALADIN: {
                id: "PALADIN", name: "è–æ®¿é¨å£«", icon: "ğŸ›¡ï¸", cost: 500, range: 65, damage: 60, hp: 1200, cooldown: 60, type: "M_TANK",
                desc: "è¿‘æˆ°å¦å…‹ã€‚é«˜è¡€é‡æ””æˆªæ•µäººï¼Œé˜²ç¦¦ç·šçš„æ ¸å¿ƒã€‚",
                upgrades: [{ cost: 800, hp: 4000, damage: 150 }, { cost: 1600, hp: 10000, damage: 500 }],
                evolutions: [
                    { id: "GUARD", name: "å®ˆè­·å¥³ç¥", icon: "ğŸ›ï¸", cost: 3000, range: 190, damage: 1000, cooldown: 140, stun: 120, desc: "çµ•å°é˜»æ“‹ä¸¦å¤§ç¯„åœéœ‡æ‡¾æ•µè»ã€‚" },
                    { id: "CRUS", name: "åå­—è»", icon: "âš”ï¸", cost: 3000, range: 175, damage: 5000, cooldown: 95, desc: "ç¥è–è™•åˆ‘ï¼Œè¿‘æˆ°æœ€å¼·æ®ºæ‹›ã€‚"}
                ]
            }
        };

        const ENEMY_PHASE_1 = [
            { icon: "ğŸ‘º", hp: 150, speed: 1.6, pDef: 10, mDef: 10, mana: 60 },
            { icon: "ğŸ§Ÿ", hp: 600, speed: 0.9, pDef: 80, mDef: 10, mana: 150 },
            { icon: "ğŸ•", hp: 200, speed: 4.2, pDef: 10, mDef: 90, mana: 120 }
        ];

        const ENEMY_PHASE_2 = [
            { icon: "ğŸ‘»", hp: 1500, speed: 1.8, pDef: 60, mDef: 200, mana: 250 },
            { icon: "ğŸ²", hp: 4000, speed: 1.1, pDef: 300, mDef: 300, mana: 600 },
            { icon: "ğŸ’€", hp: 2500, speed: 3.5, pDef: 500, mDef: 50, mana: 400 }
        ];

        /** * --- SECTION 2: å·¥å…·èˆ‡é€šç”¨çµ„ä»¶ --- */
        const GameUtils = {
            getEnemyScaling: (wave) => {
                if (wave <= 5) return 0.2 + wave * 0.12;
                if (wave <= 10) return 1.0 + (wave - 5) * 0.45;
                return 3.5 * Math.pow(1.38, wave - 10);
            },
            snapToGrid: (v) => Math.floor(v / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2,
            distToSegment: (p, v, w) => {
                const l2 = Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
                if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
                let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
            }
        };

        const StatusBar = ({ wave, mana, hp, gameSpeed, setGameSpeed, hitEffect }) => (
            <div className="absolute top-0 inset-x-0 p-5 flex justify-between items-start z-50 pointer-events-none">
                <div className="pointer-events-auto flex flex-col gap-2">
                    <h1 className="text-2xl font-black italic text-white drop-shadow-lg tracking-tighter leading-none">PHASE <span className="text-[#ff66aa]">{wave}</span></h1>
                    <div className="flex gap-1.5 mt-1">
                        {[1, 1.5, 2].map(s => (
                            <button key={s} onClick={() => setGameSpeed(s)} className={`speed-btn px-3 py-1 rounded-lg text-xs font-black border border-white/10 glass-gold transition-all ${gameSpeed === s ? 'active' : 'opacity-40'}`}>{s}x</button>
                        ))}
                    </div>
                </div>
                <div className="flex gap-2 pointer-events-auto items-center">
                    <div className="glass-gold p-2 px-3 rounded-xl border-amber-400/40 flex items-center gap-2"><p className="text-lg font-black text-amber-400">ğŸ’{mana}</p></div>
                    <div className={`glass-gold p-2 px-3 rounded-xl border-rose-400/40 flex items-center gap-2 transition-all ${hitEffect ? 'bg-red-600 scale-110' : ''}`}><p className="text-lg font-black text-white">â¤ï¸{hp}</p></div>
                </div>
            </div>
        );

        function App() {
            const canvasRef = useRef(null);
            const [gameState, setGameState] = useState('menu'); 
            const [mana, setMana] = useState(800);
            const [hp, setHp] = useState(30);
            const [wave, setWave] = useState(1);
            const [selectedType, setSelectedType] = useState(null);
            const [unitToUpgrade, setUnitToUpgrade] = useState(null);
            const [mousePos, setMousePos] = useState({ x: -1000, y: -1000 });
            const [gameSpeed, setGameSpeed] = useState(1);
            const [waveTimer, setWaveTimer] = useState(0);
            const [castleHit, setCastleHit] = useState(false);
            const [showHowTo, setShowHowTo] = useState(false);

            const [camOffset, setCamOffset] = useState({ x: 0, y: 0 });
            const isDragging = useRef(false);
            const lastDrag = useRef({ x: 0, y: 0 });

            // éŠæˆ²å¯¦é«”æ•¸æ“š
            const units = useRef([]);
            const enemies = useRef([]);
            const projectiles = useRef([]);
            const trees = useRef([]);
            const fx = useRef([]); 
            const frame = useRef(0);
            const spawned = useRef(0);
            const waveInSession = useRef(false);
            
            const pathPoints = useRef([
                { x: -50, y: 175 }, { x: 325, y: 175 }, { x: 325, y: 475 },
                { x: 75, y: 475 }, { x: 75, y: 850 }, { x: 500, y: 850 }
            ]);

            const initEnv = () => {
                const newTrees = [];
                for(let i=0; i<8; i++) {
                    for(let j=0; j<18; j++) {
                        const tx = i * GRID_SIZE + GRID_SIZE/2, ty = j * GRID_SIZE + GRID_SIZE/2;
                        let blocked = false;
                        for(let k=0; k < pathPoints.current.length-1; k++) {
                            if (GameUtils.distToSegment({x:tx, y:ty}, pathPoints.current[k], pathPoints.current[k+1]) < 48) { blocked = true; break; }
                        }
                        if (!blocked && Math.random() < 0.22) newTrees.push({ x: tx, y: ty, type: Math.random() > 0.5 ? "ğŸŒ²" : "ğŸŒ³" });
                    }
                }
                trees.current = newTrees;
            };

            const startMission = () => {
                setMana(800); setHp(30); setWave(1); spawned.current = 0; setWaveTimer(0);
                waveInSession.current = true; setCamOffset({ x: 0, y: 0 });
                initEnv(); units.current = []; enemies.current = []; projectiles.current = []; fx.current = [];
                setGameState('playing');
            };

            const handlePointerDown = (e) => {
                if (gameState !== 'playing') return;
                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                const rx = x - camOffset.x, ry = y - camOffset.y;
                const gx = GameUtils.snapToGrid(rx), gy = GameUtils.snapToGrid(ry);

                const clicked = units.current.find(u => Math.hypot(u.x - gx, u.y - gy) < 22);
                if (clicked) { setUnitToUpgrade(clicked); setSelectedType(null); return; }

                if (selectedType) {
                    if (trees.current.some(t => t.x === gx && t.y === gy)) return;
                    const t = UNIT_DATA[selectedType];
                    if (mana >= t.cost) {
                        units.current.push({ ...JSON.parse(JSON.stringify(t)), x: gx, y: gy, level: 1, lastShot: 0, currentHp: t.hp || 100, maxHp: t.hp || 100, atkCount: 0 });
                        setMana(m => m - t.cost);
                    }
                } else {
                    isDragging.current = true;
                    lastDrag.current = { x: e.clientX, y: e.clientY };
                }
            };

            const handlePointerMove = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                setMousePos({ x: e.clientX - rect.left, y: e.clientY - rect.top });
                if (isDragging.current) {
                    const dy = e.clientY - lastDrag.current.y;
                    setCamOffset(prev => ({ ...prev, y: Math.min(0, Math.max(-450, prev.y + dy)) }));
                    lastDrag.current = { x: e.clientX, y: e.clientY };
                }
            };

            const handleUpgrade = (isDismantle = false, evoObj = null) => {
                const u = unitToUpgrade;
                if (!u) return;
                if (isDismantle) {
                    setMana(m => m + Math.floor(u.cost * 0.75));
                    enemies.current.forEach(e => { if (e.blocker === u) e.blocker = null; });
                    units.current = units.current.filter(item => item !== u);
                    setUnitToUpgrade(null); return;
                }
                if (evoObj) {
                    if (mana >= evoObj.cost) {
                        setMana(m => m - evoObj.cost);
                        Object.assign(u, evoObj);
                        u.level = "MAX";
                        if (evoObj.hp) { u.maxHp = evoObj.hp; u.currentHp = evoObj.hp; }
                        setUnitToUpgrade(null);
                    }
                    return;
                }
                if (u.level < 3) {
                    const d = u.upgrades[u.level - 1];
                    if (mana >= d.cost) {
                        setMana(m => m - d.cost);
                        u.level++; u.damage = d.damage; u.range = d.range;
                        if (d.hp) { u.maxHp = d.hp; u.currentHp = d.hp; }
                        if (d.heal) u.heal = d.heal;
                        setUnitToUpgrade(null);
                    }
                }
            };

            useEffect(() => {
                if (gameState !== 'playing') return;
                const ctx = canvasRef.current.getContext('2d');
                let aid;

                const loop = () => {
                    const steps = Math.ceil(gameSpeed);
                    for(let s = 0; s < steps; s++) {
                        if (waveTimer > 0) { if (frame.current % 60 === 0) setWaveTimer(t => Math.max(0, t - 1)); frame.current++; } 
                        else if (waveInSession.current) {
                            frame.current++;
                            if (spawned.current < 20 && frame.current % 75 === 0) {
                                const pool = wave <= 10 ? ENEMY_PHASE_1 : ENEMY_PHASE_2;
                                const b = pool[Math.floor(Math.random() * 3)];
                                const scale = GameUtils.getEnemyScaling(wave);
                                enemies.current.push({ ...b, hp: b.hp * scale, currentHp: b.hp * scale, speed: b.speed * (wave <= 5 ? 0.7 : 1 + (wave-5)*0.035), x: pathPoints.current[0].x, y: pathPoints.current[0].y, pi: 0, dead: false, blocker: null });
                                spawned.current++;
                            }
                            if (spawned.current >= 20 && enemies.current.length === 0) {
                                if (wave < 20) { setWave(w => w + 1); spawned.current = 0; setWaveTimer(10); setMana(m => m + 700); }
                                else setGameState('win');
                            }
                        }

                        // æ•µäºº AI
                        enemies.current.forEach(e => {
                            if (e.blocker) {
                                if (e.blocker.currentHp <= 0) { e.blocker = null; }
                                else { if (frame.current % 60 === 0) e.blocker.currentHp -= 22; return; }
                            }
                            const t = pathPoints.current[e.pi + 1];
                            if (t) {
                                const dx = t.x - e.x, dy = t.y - e.y, d = Math.hypot(dx, dy);
                                if (d < e.speed) e.pi++; 
                                else {
                                    const nx = e.x + (dx/d)*e.speed, ny = e.y + (dy/d)*e.speed;
                                    const b = units.current.find(u => u.type === 'M_TANK' && Math.hypot(u.x - nx, u.y - ny) < 18);
                                    if (b) e.blocker = b; else { e.x = nx; e.y = ny; }
                                }
                            } else { 
                                setHp(h => { if(h <= 1) setGameState('gameover'); return h-1; }); 
                                setCastleHit(true); setTimeout(() => setCastleHit(false), 250); e.dead = true; 
                            }
                        });

                        // å–®ä½è¡Œä½
                        units.current.forEach(u => {
                            if (u.type.includes("HEAL") && frame.current % u.cooldown === 0) {
                                const t = units.current.find(o => o.type === 'M_TANK' && o.currentHp < o.maxHp && Math.hypot(u.x - o.x, u.y - o.y) < u.range);
                                if (t) { t.currentHp = Math.min(t.maxHp, t.currentHp + u.heal); fx.current.push({ x: t.x, y: t.y, color: "#55efc4", life: 30, type: "ring" }); }
                            }
                            if (u.type.includes("PHYS") || u.type.includes("MAGIC") || u.type.includes("HYBRID") || u.type === "M_TANK") {
                                if (frame.current - u.lastShot > u.cooldown) {
                                    const t = enemies.current.find(e => !e.dead && Math.hypot(u.x - e.x, u.y - e.y) < u.range);
                                    if (t) {
                                        let fd = u.damage; u.atkCount++;
                                        if (u.id.includes("ARCHER") && u.atkCount % 5 === 0) { fd *= 3.5; fx.current.push({ x: u.x, y: u.y, color: "#7ed4ff", life: 20, type: "flash" }); }
                                        const finalD = u.type.includes("PHYS") ? Math.max(5, fd - t.pDef) : u.type.includes("MAGIC") ? Math.max(5, fd - t.mDef) : Math.max(10, fd - (t.pDef+t.mDef)/5);
                                        projectiles.current.push({ x: u.x, y: u.y, target: t, d: finalD, s: 25, c: u.color || "#fff", dead: false });
                                        u.lastShot = frame.current;
                                    }
                                }
                            }
                        });

                        fx.current.forEach(f => f.life--); fx.current = fx.current.filter(f => f.life > 0);
                        projectiles.current.forEach(p => {
                            const dx = p.target.x - p.x, dy = p.target.y - p.y, dist = Math.hypot(dx, dy);
                            if (dist < p.s || p.target.dead) {
                                if (!p.target.dead) { p.target.currentHp -= p.d; if (p.target.currentHp <= 0) { p.target.dead = true; setMana(m => m + p.target.mana); } }
                                p.dead = true;
                            } else { p.x += (dx/dist)*p.s; p.y += (dy/dist)*p.s; }
                        });
                        enemies.current = enemies.current.filter(e => !e.dead);
                        projectiles.current = projectiles.current.filter(p => !p.dead);
                        units.current = units.current.filter(u => u.currentHp > 0);
                    }

                    // æ¸²æŸ“
                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    ctx.save(); ctx.translate(camOffset.x, camOffset.y);
                    // åœ°åœ–
                    ctx.beginPath(); ctx.strokeStyle = "#4d3a24"; ctx.lineWidth = 62; ctx.lineJoin = "round";
                    ctx.moveTo(pathPoints.current[0].x, pathPoints.current[0].y); pathPoints.current.forEach(p => ctx.lineTo(p.x, p.y)); ctx.stroke();
                    // åŸå ¡
                    const cp = pathPoints.current[pathPoints.current.length-1];
                    ctx.save(); ctx.shadowBlur = 20; ctx.shadowColor = "white"; ctx.font = "95px serif"; ctx.textAlign = "center"; 
                    if (castleHit) ctx.fillStyle = "rgba(255,0,0,0.7)"; ctx.fillText("ğŸ°", cp.x - 25, cp.y + 20); ctx.restore();
                    // å¯¦é«”
                    trees.current.forEach(t => { ctx.font = "34px serif"; ctx.fillText(t.type, t.x, t.y + 12); });
                    fx.current.forEach(f => { ctx.beginPath(); ctx.strokeStyle = f.color; ctx.lineWidth = 2; if(f.type === "ring") ctx.arc(f.x, f.y, 40 - f.life, 0, 7); else ctx.arc(f.x, f.y, 25, 0, 7); ctx.stroke(); });
                    units.current.forEach(u => {
                        ctx.beginPath(); ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.arc(u.x, u.y, 24, 0, 7); ctx.fill();
                        ctx.font = "44px serif"; ctx.textAlign = "center"; ctx.fillText(u.icon, u.x, u.y + 16);
                        if(u.type === 'M_TANK') { ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.fillRect(u.x-20, u.y+24, 40, 5); ctx.fillStyle="#55efc4"; ctx.fillRect(u.x-20, u.y+24, (u.currentHp/u.maxHp)*40, 5); }
                    });
                    enemies.current.forEach(e => {
                        ctx.font = "38px serif"; ctx.fillText(e.icon, e.x, e.y + 14);
                        ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(e.x - 22, e.y - 36, 44, 6);
                        ctx.fillStyle = "#ff4d94"; ctx.fillRect(e.x - 22, e.y - 36, (e.currentHp/e.hp)*44, 6);
                    });
                    projectiles.current.forEach(p => { ctx.fillStyle = p.c; ctx.shadowBlur = 20; ctx.shadowColor = p.c; ctx.beginPath(); ctx.arc(p.x, p.y, 6.5, 0, 7); ctx.fill(); ctx.shadowBlur = 0; });
                    ctx.restore();

                    // å¸é™„è™›å½±
                    if (gameState === 'playing' && selectedType && !unitToUpgrade) {
                        const a = UNIT_DATA[selectedType];
                        const sx = GameUtils.snapToGrid(mousePos.x - camOffset.x), sy = GameUtils.snapToGrid(mousePos.y - camOffset.y);
                        const block = trees.current.some(t => t.x === sx && t.y === sy);
                        ctx.save(); ctx.globalAlpha = 0.5; ctx.font = "44px serif"; ctx.textAlign = "center";
                        ctx.fillText(a.icon, sx + camOffset.x, sy + camOffset.y + 16);
                        ctx.beginPath(); ctx.strokeStyle = block ? "#ff0000" : a.color || "#fff"; ctx.lineWidth = 4; ctx.setLineDash([10, 5]); ctx.arc(sx + camOffset.x, sy + camOffset.y, a.range, 0, 7); ctx.stroke(); ctx.restore();
                    }
                    aid = requestAnimationFrame(loop);
                };
                aid = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(aid);
            }, [gameState, wave, gameSpeed, selectedType, unitToUpgrade, mousePos, camOffset, waveTimer, castleHit]);

            return (
                <div className="relative w-full h-screen flex flex-col bg-[#0f120d] overflow-hidden select-none">
                    <div className="scan-line"></div>
                    <StatusBar wave={wave} mana={mana} hp={hp} gameSpeed={gameSpeed} setGameSpeed={setGameSpeed} hitEffect={castleHit} />

                    <div className="flex-1 relative flex items-center justify-center">
                        <canvas ref={canvasRef} width={400} height={750} onPointerDown={handlePointerDown} onPointerMove={handlePointerMove} onPointerUp={() => isDragging.current = false} onPointerLeave={() => isDragging.current = false} />
                        
                        {unitToUpgrade && (
                            <div className="absolute inset-0 bg-black/70 backdrop-blur-md z-[70] flex items-center justify-center p-6">
                                <div className="glass-gold p-8 rounded-[3rem] w-full max-w-[340px] animate-fade-up">
                                    <div className="flex justify-between items-center mb-6"><span className="text-7xl drop-shadow-lg">{unitToUpgrade.icon}</span><button onClick={() => setUnitToUpgrade(null)} className="text-white/30 p-3 text-4xl">âœ•</button></div>
                                    <p className="font-black text-2xl mb-1">{unitToUpgrade.name}</p>
                                    <p className="text-sm opacity-60 mb-8 leading-relaxed italic text-white/80">{unitToUpgrade.desc}</p>
                                    <div className="flex flex-col gap-4">
                                        {unitToUpgrade.level < 3 ? (
                                            <button onClick={() => handleUpgrade(false)} disabled={mana < (unitToUpgrade.upgrades[unitToUpgrade.level-1]?.cost || 9999)} className="w-full py-5 main-btn rounded-3xl font-black text-lg disabled:opacity-20">å¼·åŒ– ğŸ’ {unitToUpgrade.upgrades[unitToUpgrade.level-1]?.cost}</button>
                                        ) : unitToUpgrade.level === 3 ? (
                                            <div className="grid grid-cols-2 gap-3">
                                                {unitToUpgrade.evolutions.map(evo => (
                                                    <button key={evo.id} onClick={() => handleUpgrade(false, evo)} disabled={mana < evo.cost} className="p-4 bg-white/5 border border-white/10 rounded-2xl flex flex-col items-center gap-2 active:bg-pink-600/30 disabled:opacity-20">
                                                        <span className="text-3xl">{evo.icon}</span><span className="text-xs font-black">{evo.name}</span><span className="text-[10px] font-black text-amber-400">ğŸ’{evo.cost}</span>
                                                    </button>
                                                ))}
                                            </div>
                                        ) : <div className="py-6 bg-emerald-500/10 border border-emerald-500/40 rounded-3xl text-center text-emerald-400 font-black italic tracking-widest uppercase">Ultimate Form</div>}
                                        <button onClick={() => handleUpgrade(true)} className="w-full py-4 border border-rose-500/30 rounded-3xl font-bold text-sm text-rose-400">æ’¤é›¢ (å›æ”¶ 75%)</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {gameState === 'menu' && (
                            <div className="absolute inset-0 bg-black/95 z-[100] flex flex-col items-center justify-center p-12 text-center">
                                <div className="hero-float mb-12"><h2 className="text-7xl font-black italic text-white drop-shadow-[0_0_30px_rgba(255,102,170,0.6)] tracking-tighter uppercase">Goddess</h2><h2 className="text-4xl font-black tracking-[0.5em] text-[#ff66aa] mt-2">DEFENSE</h2></div>
                                <div className="flex flex-col gap-5 w-full max-w-[280px]">
                                    <button onClick={startMission} className="w-full bg-[#ff66aa] text-white py-6 rounded-full font-black text-2xl active:scale-95 shadow-xl">å¬å–šå‡ºå¾</button>
                                    <button onClick={() => setShowHowTo(true)} className="w-full bg-white/5 border border-white/20 text-white py-4 rounded-full font-black text-lg uppercase tracking-widest">éŠæˆ²èªªæ˜</button>
                                </div>
                            </div>
                        )}

                        {showHowTo && (
                            <div className="absolute inset-0 bg-black/90 backdrop-blur-xl z-[110] flex items-center justify-center p-8">
                                <div className="w-full max-w-sm text-left space-y-8 py-10 no-scrollbar overflow-y-auto max-h-[90vh]">
                                    <section><h3 className="text-2xl font-black text-[#ff66aa] mb-3">ã€æ•…äº‹ç·£èµ·ã€‘</h3><p className="text-base opacity-80 leading-loose">é­”ç‹è»è‡ªæ·±æ·µè¦ºé†’ï¼Œä¼åœ–æ‘§æ¯€æ£®æ—æ ¸å¿ƒã€‚ä½œç‚ºå®ˆè­·å®˜ï¼Œä½ å¿…é ˆå¬å–šå¯„å®¿åœ¨ç¥å…µä¸­çš„å¥³ç¥ï¼Œå®ˆè­·ç¥è–åŸå ¡ã€‚</p></section>
                                    <section><h3 className="text-2xl font-black text-[#ff66aa] mb-3">ã€æˆ°é¬¥æ–¹å¼ã€‘</h3><ul className="text-base space-y-3 opacity-80"><li>â— è¿‘æˆ°å¦å…‹ï¼šæ”¾æ–¼ç©ºåœ°ï¼Œå¯¦é«”æ””æˆªæ•µè»ã€‚</li><li>â— é ç¨‹è¼¸å‡ºï¼šè² è²¬ä¸»è¦å‚·å®³ã€‚</li><li>â— ç‰§å¸«ï¼šæä¾›é—œéµæ²»ç™‚ã€‚</li><li>â— é€²åŒ–ï¼šLv.3 å¾Œå¯é¸æ“‡å…©æ¢çµ‚æ¥µåˆ†æ­§ã€‚</li></ul></section>
                                    <section><h3 className="text-2xl font-black text-[#ff66aa] mb-3">ã€å‹æ•—æ¢ä»¶ã€‘</h3><p className="text-base opacity-80">â— å‹åˆ©ï¼šæŠµç¦¦ 20 æ³¢é­”ç‹è»ã€‚<br/>â— å¤±æ•—ï¼šåŸå ¡ HP æ­¸é›¶ã€‚</p></section>
                                    <button onClick={() => setShowHowTo(false)} className="w-full bg-white text-black py-4 rounded-full font-black text-xl">ç†è§£å¥‘çº¦</button>
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="glass-gold fixed bottom-0 left-0 w-full p-4 pb-12 z-[40] border-t-2 border-[#ff66aa]/40 flex flex-col gap-4">
                        {selectedType && (
                            <div className="px-6 py-4 bg-black/60 border border-white/10 rounded-[2.5rem] flex justify-between items-center">
                                <div className="flex-1"><p className="text-lg font-black text-[#ff66aa] tracking-tighter">{UNIT_DATA[selectedType].name}</p><p className="text-sm opacity-90 leading-relaxed italic text-white/70">{UNIT_DATA[selectedType].desc}</p></div>
                                <button onClick={() => setSelectedType(null)} className="ml-4 w-10 h-10 flex items-center justify-center bg-white/10 rounded-full text-xl text-white/40">âœ•</button>
                            </div>
                        )}
                        <div className="flex overflow-x-auto gap-4 px-4 no-scrollbar">
                            {Object.entries(UNIT_DATA).map(([key, info]) => (
                                <button key={key} onClick={() => { setSelectedType(key); setUnitToUpgrade(null); }} className={`unit-card relative p-5 min-w-[100px] rounded-[2.2rem] border-2 flex flex-col items-center justify-center gap-1.5 ${selectedType === key ? 'active' : 'border-white/5 bg-white/5 opacity-50 grayscale-[0.3]'}`}>
                                    <span className="text-5xl">{info.icon}</span>
                                    <span className="text-[14px] font-black text-amber-400 leading-none">ğŸ’{info.cost}</span>
                                    {mana < info.cost && <div className="absolute inset-0 bg-black/70 rounded-[2.2rem] flex items-center justify-center text-[11px] font-black text-rose-500 uppercase tracking-widest">Wait</div>}
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
