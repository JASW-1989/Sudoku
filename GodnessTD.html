<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Goddess Defense v25.3 - UX & Logic Alignment</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@700&family=Noto+Sans+TC:wght@400;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #f4f1ea; margin: 0; overflow: hidden; color: #4a4238; font-weight: 400; }
        .font-black { font-weight: 900 !important; }
        canvas { display: block; background: #fdfaf5; width: 100vw; height: 100vh; cursor: grab; touch-action: none; }
        .glass-ui { background: rgba(255, 250, 240, 0.95); backdrop-filter: blur(15px); border: 1px solid rgba(139, 121, 94, 0.15); color: #4a4238; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .font-game { font-family: 'JetBrains Mono', monospace; font-weight: 700; }
        .deck-transition { transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1); }
        .spinner { border: 3px solid rgba(139, 121, 94, 0.1); border-top-color: #8b795e; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .detail-panel { position: absolute; top: -110px; left: 10px; right: 10px; z-index: 10; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        /**
         * [v25.3 聖域最終修正版]
         * 1. 修正近戰/陷阱放置判定：陷阱與坦克強制放置於道路。
         * 2. 修復主動技能與 UI 重疊：移動 MiracleBar 至右側。
         * 3. 手機版 UI 適配：UpgradePanel 縮小。
         * 4. 核心邏輯補全：法力過載、Boss 產生機制修復。
         */
        const { useState, useEffect, useRef, useCallback } = React;
        const e = React.createElement;

        const VER = Date.now();
        const BASE = "https://jasw-1989.github.io/Sudoku";
        const MODULES = {
            Engine: `${BASE}/js/engine.js?v=${VER}`,
            Renderer: `${BASE}/js/renderer.js?v=${VER}`,
            Utils: `${BASE}/js/utils.js?v=${VER}`,
            Entities: `${BASE}/js/entities.js?v=${VER}`,
            UI: `${BASE}/js/ui_components.js?v=${VER}`
        };

        const ENDPOINTS = {
            UNITS: `${BASE}/units_config.json?v=${VER}`,
            MONSTERS: `${BASE}/monsters_config.json?v=${VER}`,
            MAP: `${BASE}/map_config.json?v=${VER}`,
            LOCALE: `${BASE}/localization_config.json?v=${VER}`,
            WAVES: `${BASE}/waves_config.json?v=${VER}`,
            BALANCE: `${BASE}/balance_config.json?v=${VER}`
        };

        function App() {
            const [res, setRes] = useState(null);
            const [mods, setMods] = useState(null); 
            const [error, setError] = useState(null);
            const [gameState, setGameState] = useState('loading'); 
            const [gamePhase, setGamePhase] = useState('prep');
            const [stats, setStats] = useState({ mana: 0, hp: 0, wave: 1, timer: 0, speed: 1 });
            const [ui, setUI] = useState({ selected: null, upgradeTarget: null, deckOpen: true });
            
            const canvasRef = useRef(null);
            const engineRef = useRef(null);
            const camXRef = useRef(0);
            const mouseRef = useRef({ x: -1000, y: -1000 });
            const dragRef = useRef({ active: false, lastX: 0 });

            useEffect(() => {
                const bootstrap = async () => {
                    try {
                        const [mEngine, mRender, mUtil, mEnt, mUI] = await Promise.all([
                            import(MODULES.Engine), import(MODULES.Renderer),
                            import(MODULES.Utils), import(MODULES.Entities),
                            import(MODULES.UI)
                        ]);

                        const f = (url) => fetch(url).then(r => r.json());
                        const [u, m, mc, l, w, b] = await Promise.all([
                            f(ENDPOINTS.UNITS), f(ENDPOINTS.MONSTERS), f(ENDPOINTS.MAP),
                            f(ENDPOINTS.LOCALE), f(ENDPOINTS.WAVES), f(ENDPOINTS.BALANCE)
                        ]);

                        const mapData = mc.configs[mc.active_map];
                        setMods({ Engine: mEngine.GameEngine, Renderer: mRender.Renderer, Utils: mUtil.Utils, UI: mUI });
                        setRes({ units: u, monsters: m, map: mapData, locale: l, waves: w, balance: b });
                        setStats(s => ({ ...s, mana: b.initial_stats.mana, hp: b.initial_stats.hp, timer: w.general.wave_duration }));
                        setGameState('menu'); 

                    } catch (e) { setError(e.message); }
                };
                bootstrap();
            }, []);

            const startBattle = useCallback(() => {
                if (!res || !mods) return;
                engineRef.current = new mods.Engine(res);
                engineRef.current.initDecor();
                engineRef.current.startWave(setStats); 
                setGameState('playing'); setGamePhase('prep');
            }, [res, mods]);

            useEffect(() => {
                if (gameState !== 'playing' || !engineRef.current || !mods) return;
                const ctx = canvasRef.current.getContext('2d');
                let aid;
                const tick = () => {
                    if (gamePhase === 'battle') {
                        const cycles = Math.ceil(stats.speed);
                        for (let i = 0; i < cycles; i++) engineRef.current.update(stats, setStats, setGameState);
                    }
                    mods.Renderer.render(ctx, canvasRef.current, engineRef.current, res, camXRef.current, ui, mouseRef.current);
                    aid = requestAnimationFrame(tick);
                };
                aid = requestAnimationFrame(tick);
                return () => cancelAnimationFrame(aid);
            }, [gameState, gamePhase, stats.speed, ui, res, mods]);

            if (error) return e('div', { className: "h-screen bg-[#f4f1ea] flex flex-col items-center justify-center p-10 text-red-600 text-center" }, error);

            if (gameState === 'loading' || !mods) return e('div', { className: "h-screen bg-[#f4f1ea] flex flex-col items-center justify-center text-[#8b795e]" }, e('div', { className: "spinner mb-8 shadow-xl" }), "ESTABLISHING_V25.3...");

            const { HUD, CommandDeck, UpgradePanel, MenuScreen, DeployOverlay, MiracleBar } = mods.UI;

            return e('div', { className: "relative w-full h-screen bg-[#fdfaf5] overflow-hidden select-none" },
                e(HUD, { 
                    stats: {...stats, setSpeed: (s) => setStats(p=>({...p, speed:s}))},
                    onTriggerNext: () => engineRef.current?.startWave(setStats),
                    castleHit: engineRef.current?.castleHit, res, visible: gameState === 'playing'
                }),

                e(MiracleBar, { 
                    mana: stats.mana, 
                    onTrigger: (type) => engineRef.current?.triggerMiracle(type, setStats),
                    visible: gameState === 'playing' && gamePhase === 'battle'
                }),

                e('canvas', {
                    ref: canvasRef, width: window.innerWidth, height: window.innerHeight,
                    onPointerDown: (ev) => {
                        if (gameState !== 'playing' || !engineRef.current) return;
                        const rect = canvasRef.current.getBoundingClientRect();
                        const vH = res.map.virtual_height || 650;
                        const sf = vH / rect.height;
                        const rx = (ev.clientX - rect.left) * sf - camXRef.current;
                        const ry = (ev.clientY - rect.top) * sf;
                        const gx = mods.Utils.snapToGrid(rx, res.map.grid_size);
                        const gy = mods.Utils.snapToGrid(ry, res.map.grid_size);
                        
                        const clicked = engineRef.current.units.find(u => mods.Utils.getDist(u, {x:gx,y:gy}) < 25);
                        if (clicked) { setUI(p => ({...p, upgradeTarget: clicked, selected: null})); return; }
                        
                        if (ui.selected) {
                            const uData = res.units[ui.selected];
                            // 修正：判定進戰與陷阱必須放在道路上
                            const isPathUnit = uData.type.includes('TANK') || uData.type.includes('TRAP');
                            const ok = isPathUnit ? mods.Utils.isOnPath(gx, gy, res.map.path) : !mods.Utils.isOnPath(gx, gy, res.map.path);
                            if (ok && stats.mana >= uData.cost) {
                                engineRef.current.deployUnit(ui.selected, gx, gy);
                                setStats(s => ({ ...s, mana: s.mana - uData.cost }));
                            }
                        } else { dragRef.current = { active: true, lastX: ev.clientX }; }
                    },
                    onPointerMove: (ev) => {
                        mouseRef.current = { x: ev.clientX, y: ev.clientY };
                        if (dragRef.current.active) {
                            camXRef.current = Math.min(0, Math.max(res.balance.initial_stats.camera_limit, camXRef.current + (ev.clientX - dragRef.current.lastX)));
                            dragRef.current.lastX = ev.clientX;
                        }
                    },
                    onPointerUp: () => dragRef.current.active = false
                }),

                e(DeployOverlay, { onExecute: () => setGamePhase('battle'), visible: gameState === 'playing' && gamePhase === 'prep' }),
                e(CommandDeck, { ui, setUI, mana: stats.mana, res, visible: gameState === 'playing' }),
                e(UpgradePanel, {
                    target: ui.upgradeTarget, onClose: () => setUI(p=>({...p, upgradeTarget:null})), mana: stats.mana,
                    onUpgrade: (evo) => {
                        const t = ui.upgradeTarget;
                        if (evo) { 
                            if (stats.mana >= evo.cost) { setStats(s => ({ ...s, mana: s.mana - evo.cost })); Object.assign(t, evo); t.level = "MAX"; setUI(p=>({...p, upgradeTarget:null})); } 
                        } else { 
                            const d = t.config.upgrades[t.level-1]; 
                            if (stats.mana >= d.cost) { setStats(s => ({ ...s, mana: s.mana - d.cost })); t.level++; t.damage = d.damage; t.range = d.range; setUI(p=>({...p, upgradeTarget:null})); } 
                        }
                    },
                    onDismiss: () => {
                        setStats(s => ({ ...s, mana: s.mana + Math.floor(ui.upgradeTarget.config.cost * 0.75) }));
                        engineRef.current.units = engineRef.current.units.filter(i => i !== ui.upgradeTarget); setUI(p=>({...p, upgradeTarget:null}));
                    }, res
                }),
                e(MenuScreen, { res, onStart: startBattle, visible: gameState === 'menu' })
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(e(App));
    </script>
</body>
</html>
