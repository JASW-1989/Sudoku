<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Goddess Defense v16.0 - Clean Portal</title>
    
    <!-- Âü∫Á§éËÖ≥Êú¨ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase Compat -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@500;700&family=Noto+Sans+TC:wght@500;900&display=swap" rel="stylesheet">
    
    <style>
        :root { --p: #ff66aa; --g: #ffd700; }
        body { font-family: 'Quicksand', 'Noto Sans TC', sans-serif; background-color: #0f120d; margin: 0; overflow: hidden; color: #fff; }
        canvas { display: block; margin: 0 auto; background: #26381a; box-shadow: 0 0 50px rgba(0,0,0,0.8); }
        .glass-gold { background: rgba(25, 30, 25, 0.96); backdrop-filter: blur(25px); border: 1px solid rgba(255, 215, 0, 0.2); }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        @keyframes floating { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-10px); } }
        .hero-float { animation: floating 3s ease-in-out infinite; }
        .spinner { border: 4px solid rgba(255,102,170,0.1); border-top-color: #ff66aa; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // 1. ÈÖçÁΩÆËàáÂ∏∏Èáè
        const DATA_MAP = {
            units: "https://jasw-1989.github.io/Sudoku/units_config.json",
            monsters: "https://jasw-1989.github.io/Sudoku/monsters_config.json",
            locale: "https://jasw-1989.github.io/Sudoku/localization_config.json"
        };

        const PATH_POINTS = [ { x: -50, y: 175 }, { x: 325, y: 175 }, { x: 325, y: 475 }, { x: 75, y: 475 }, { x: 75, y: 850 }, { x: 500, y: 850 } ];

        /**
         * Á∞°ÂåñËºâÂÖ•Áï´Èù¢
         */
        const Overlay = ({ title, sub, btn, onBtn }) => (
            <div className="fixed inset-0 bg-black/95 flex flex-col items-center justify-center z-[500] text-center p-12">
                <div className="hero-float mb-12">
                    <h1 className="text-7xl font-black italic text-transparent bg-clip-text bg-gradient-to-b from-white to-white/20 tracking-tighter uppercase leading-none font-serif">{title}</h1>
                    <h2 className="text-3xl font-black tracking-[0.6em] text-[#ff66aa] mt-2">{sub}</h2>
                </div>
                <button onClick={onBtn} className="w-full max-w-[280px] bg-[#ff66aa] py-5 rounded-full font-black text-xl shadow-2xl active:scale-95 transition-all">{btn}</button>
            </div>
        );

        function App() {
            // --- ÁãÄÊÖãÊéßÂà∂ ---
            const [resources, setResources] = useState(null);
            const [status, setStatus] = useState({ loading: true, error: null, step: "ÂàùÂßãÂåñËÅñÂüüÈñÄÊà∂..." });
            const [game, setGame] = useState({ active: false, mana: 1000, hp: 30, wave: 1, speed: 1, hit: false });
            const [ui, setUI] = useState({ selected: null, upgrade: null });

            // --- ÂºïÊìéÂºïÁî® ---
            const canvasRef = useRef(null);
            const mouseRef = useRef({ x: -1000, y: -1000 });
            const camRef = useRef({ y: 0 });
            const entities = useRef({ units: [], enemies: [], projectiles: [], fx: [], trees: [] });
            const engine = useRef({ frame: 0, spawned: 0, waveTimer: 0 });

            /** * [Á∞°ÂåñÊï∏ÊìöËÆÄÂèñ] GitHub -> Local -> Cache 
             */
            useEffect(() => {
                const loadAll = async () => {
                    const fetchJSON = async (url) => {
                        try {
                            const r = await fetch(url, { cache: 'no-store' });
                            return r.ok ? await r.json() : null;
                        } catch (e) { return null; }
                    };

                    try {
                        const results = {};
                        for (const [key, remoteUrl] of Object.entries(DATA_MAP)) {
                            setStatus(s => ({ ...s, step: `ËÆÄÂèñ ${key}...` }));
                            // 1. GitHub 2. Local 3. Cache
                            let data = await fetchJSON(`${remoteUrl}?t=${Date.now()}`);
                            if (!data) data = await fetchJSON(`./${key}_config.json`);
                            if (!data) data = JSON.parse(localStorage.getItem(`cache_${key}`));
                            
                            if (data) {
                                results[key] = data;
                                localStorage.setItem(`cache_${key}`, JSON.stringify(data));
                            } else {
                                throw new Error(`Êï∏ÊìöÊ†∏ÂøÉÈÅ∫Â§±: ${key}`);
                            }
                        }
                        setResources(results);
                        setStatus({ loading: false, error: null });
                    } catch (e) {
                        setStatus({ loading: false, error: e.message });
                    }
                };
                loadAll();
            }, []);

            /**
             * [ËΩâÊèõÁ®ãÂºèÁ¢º] Â∞á JSON ËΩâÁÇ∫Âü∑Ë°åÁâ©‰ª∂
             */
            const spawnUnit = (data, x, y) => ({
                ...JSON.parse(JSON.stringify(data)),
                x, y, level: 1, lastShot: 0, atkCount: 0, silencedUntil: 0,
                currentHp: data.hp || 1200, maxHp: data.hp || 1200, currentDur: data.durability || 0, dead: false
            });

            /**
             * [Áπ™ÂúñÂºïÊìé]
             */
            useEffect(() => {
                if (status.loading || !game.active) return;
                const ctx = canvasRef.current.getContext('2d');
                let aid;

                const mainLoop = () => {
                    const steps = Math.ceil(game.speed);
                    for (let s = 0; s < steps; s++) {
                        // Ê≥¢Ê¨°ÈÇèËºØ
                        if (engine.current.waveTimer > 0) {
                            if (engine.current.frame % 60 === 0) engine.current.waveTimer--;
                        } else {
                            if (game.wave % 10 === 0 && engine.current.spawned === 0) {
                                const b = game.wave === 10 ? resources.monsters.boss10 : resources.monsters.boss20;
                                entities.current.enemies.push({ ...JSON.parse(JSON.stringify(b)), currentHp: b.hp, x: PATH_POINTS[0].x, y: PATH_POINTS[0].y, pi: 0, dead: false, blocker: null, skillTimer: 0 });
                                engine.current.spawned = 1;
                            } else if (engine.current.spawned < 20 && engine.current.frame % 75 === 0 && game.wave % 10 !== 0) {
                                const pool = game.wave < 10 ? resources.monsters.phase1 : resources.monsters.phase2;
                                const b = pool[Math.floor(Math.random() * pool.length)];
                                const sc = game.wave <= 5 ? (0.2 + game.wave * 0.12) : 4.5 * Math.pow(1.35, game.wave - 10);
                                entities.current.enemies.push({ ...JSON.parse(JSON.stringify(b)), hp: b.hp * sc, currentHp: b.hp * sc, speed: b.speed * 1.1, x: PATH_POINTS[0].x, y: PATH_POINTS[0].y, pi: 0, dead: false, blocker: null });
                                engine.current.spawned++;
                            }
                            if (engine.current.spawned >= (game.wave % 10 === 0 ? 1 : 20) && entities.current.enemies.length === 0) {
                                setGame(g => ({ ...g, wave: g.wave + 1, mana: g.mana + 1000 }));
                                engine.current.spawned = 0; engine.current.waveTimer = 10;
                            }
                        }

                        // AI & Á¢∞Êíû (Á∞°ÂåñÁâà)
                        entities.current.enemies.forEach(e => {
                            if (e.blocker && e.blocker.currentHp > 0) {
                                if (engine.current.frame % 60 === 0) e.blocker.currentHp -= e.isBoss ? 500 : 70;
                            } else {
                                const t = PATH_POINTS[e.pi + 1];
                                if (t) {
                                    const d = Math.hypot(t.x - e.x, t.y - e.y);
                                    if (d < e.speed) e.pi++; else { e.x += ((t.x-e.x)/d)*e.speed; e.y += ((t.y-e.y)/d)*e.speed; }
                                    const b = entities.current.units.find(u => u.type?.includes('TANK') && Math.hypot(u.x - e.x, u.y - e.y) < 25);
                                    if (b) e.blocker = b;
                                } else { setGame(g => ({...g, hp: g.hp - 1, hit: true})); setTimeout(()=>setGame(g=>({...g, hit:false})), 200); e.dead = true; }
                            }
                        });

                        entities.current.units.forEach(u => {
                            if (engine.current.frame - u.lastShot > u.cooldown) {
                                const t = entities.current.enemies.find(e => !e.dead && Math.hypot(u.x-e.x, u.y-e.y) < u.range);
                                if (t) {
                                    entities.current.projectiles.push({ x: u.x, y: u.y, target: t, d: u.damage, s: 28, c: u.color || "#fff", dead: false });
                                    u.lastShot = engine.current.frame;
                                }
                            }
                        });

                        entities.current.projectiles.forEach(p => {
                            const d = Math.hypot(p.target.x - p.x, p.target.y - p.y);
                            if (d < p.s || p.target.dead) {
                                if (!p.target.dead) { p.target.currentHp -= p.d; if (p.target.currentHp <= 0) { p.target.dead = true; setGame(g => ({...g, mana: g.mana + 120})); } }
                                p.dead = true;
                            } else { p.x += ((p.target.x-p.x)/d)*p.s; p.y += ((p.target.y-p.y)/d)*p.s; }
                        });

                        entities.current.enemies = entities.current.enemies.filter(e => !e.dead);
                        entities.current.projectiles = entities.current.projectiles.filter(p => !p.dead);
                        entities.current.units = entities.current.units.filter(u => u.currentHp > 0);
                        engine.current.frame++;
                    }

                    // Ê∏≤ÊüìÂ±§
                    ctx.clearRect(0, 0, CANVAS_DIM.W, CANVAS_DIM.H);
                    ctx.save(); ctx.translate(0, camRef.current.y);
                    ctx.beginPath(); ctx.strokeStyle = "#4d3a24"; ctx.lineWidth = 62; ctx.lineJoin = "round";
                    ctx.moveTo(PATH_POINTS[0].x, PATH_POINTS[0].y); PATH_POINTS.forEach(p => ctx.lineTo(p.x, p.y)); ctx.stroke();
                    
                    const cp = PATH_POINTS[PATH_POINTS.length-1];
                    ctx.save(); ctx.shadowBlur = 40; ctx.shadowColor = "#ff66aa"; ctx.font = "95px serif"; ctx.textAlign = "center"; 
                    ctx.fillText("üè∞", cp.x - 25, cp.y + 20); ctx.restore();

                    entities.current.units.forEach(u => {
                        ctx.beginPath(); ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.arc(u.x, u.y, 24, 0, 7); ctx.fill();
                        ctx.font = "44px serif"; ctx.textAlign = "center"; ctx.fillText(u.icon, u.x, u.y + 16);
                        ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.fillRect(u.x-20, u.y+24, 40, 5); ctx.fillStyle="#55efc4"; ctx.fillRect(u.x-20, u.y+24, (u.currentHp/u.maxHp)*40, 5);
                    });
                    entities.current.enemies.forEach(e => {
                        ctx.font = `${e.isBoss?110:38}px serif`; ctx.fillText(e.icon, e.x, e.y + 14);
                        const bw = e.isBoss ? 100 : 44; ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(e.x - bw/2, e.y - (e.isBoss?60:36), bw, 7);
                        ctx.fillStyle = e.isBoss ? "#e74c3c" : "#ff4d94"; ctx.fillRect(e.x - bw/2, e.y - (e.isBoss?60:36), (e.currentHp/e.hp)*bw, 7);
                    });
                    entities.current.projectiles.forEach(p => { ctx.fillStyle = p.c; ctx.beginPath(); ctx.arc(p.x, p.y, 6.5, 0, 7); ctx.fill(); });

                    // ËôõÂΩ±
                    if (ui.selected && !ui.upgrade) {
                        const a = resources.units[ui.selected];
                        const sx = Math.floor(mouseRef.current.x / 50) * 50 + 25;
                        const sy = Math.floor((mouseRef.current.y - camRef.current.y) / 50) * 50 + 25;
                        ctx.save(); ctx.globalAlpha = 0.5; ctx.font = "44px serif"; ctx.textAlign = "center"; ctx.fillText(a.icon, sx, sy + 16);
                        ctx.beginPath(); ctx.strokeStyle = "#fff"; ctx.lineWidth = 4; ctx.setLineDash([10, 5]); ctx.arc(sx, sy, a.range, 0, 7); ctx.stroke(); ctx.restore();
                    }
                    ctx.restore(); aid = requestAnimationFrame(mainLoop);
                };
                aid = requestAnimationFrame(mainLoop);
                return () => cancelAnimationFrame(aid);
            }, [game.active, game.speed, ui.selected, ui.upgrade, game.wave]);

            if (status.loading) return (
                <div className="fixed inset-0 bg-[#0a0a0c] flex flex-col items-center justify-center text-white">
                    <div className="spinner mb-8"></div>
                    <p className="font-black tracking-[0.3em] uppercase animate-pulse text-[#ff66aa]">{status.step}</p>
                </div>
            );

            if (status.error) return <Overlay title="ERROR" sub={status.error} btn="REBOOT" onBtn={() => window.location.reload()} />;

            return (
                <div className="relative w-full h-screen bg-[#0f120d] overflow-hidden select-none font-sans">
                    {/* HUD */}
                    <div className="absolute top-0 inset-x-0 p-6 flex justify-between items-start z-50 pointer-events-none">
                        <div className="pointer-events-auto space-y-2">
                            <div className="glass-gold p-2 px-4 rounded-xl border-white/10 border"><h1 className="text-3xl font-black italic text-white leading-none">P-{game.wave}</h1></div>
                            <div className="flex gap-1">
                                {[1, 2].map(s => (
                                    <button key={s} onClick={() => setGame(p=>({...p, speed: s}))} className={`px-4 py-1 rounded-lg text-[10px] font-black border transition-all ${game.speed === s ? 'bg-[#ff66aa] text-white' : 'bg-black/40 text-white/40'}`}>{s}x</button>
                                ))}
                            </div>
                        </div>
                        <div className="flex gap-2 pointer-events-auto">
                            <div className="glass-gold p-3 rounded-2xl border-amber-400/20 flex items-center gap-3"><span className="text-xl font-black text-amber-400 font-mono">{game.mana}</span></div>
                            <div className={`glass-gold p-3 rounded-2xl border-rose-400/20 flex items-center gap-3 transition-all ${game.hit ? 'bg-red-600' : ''}`}><span className="text-xl font-black text-white font-mono">{game.hp}</span></div>
                        </div>
                    </div>
                    
                    <div className="flex-1 h-full flex items-center justify-center">
                        <canvas ref={canvasRef} width={400} height={750} onPointerDown={(e) => {
                            if (!game.active) return;
                            const rect = canvasRef.current.getBoundingClientRect();
                            const gx = Math.floor((e.clientX - rect.left) / 50) * 50 + 25;
                            const gy = Math.floor((e.clientY - rect.top - camRef.current.y) / 50) * 50 + 25;
                            const clicked = entities.current.units.find(u => Math.hypot(u.x-gx, u.y-gy) < 22);
                            if (clicked) setUI(p => ({...p, upgrade: clicked, selected: null}));
                            else if (ui.selected && game.mana >= resources.units[ui.selected].cost) {
                                entities.current.units.push(spawnUnit(resources.units[ui.selected], gx, gy));
                                setGame(g => ({...g, mana: g.mana - resources.units[ui.selected].cost}));
                            }
                        }} onPointerMove={(e) => {
                            const rect = canvasRef.current.getBoundingClientRect();
                            mouseRef.current = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                        }} />

                        {!game.active && <Overlay title={resources.locale.menu.title_main} sub={resources.locale.menu.title_sub} btn={resources.locale.menu.btn_start} onBtn={() => setGame(p => ({...p, active: true}))} />}
                    </div>

                    {/* Âç°Áâå */}
                    <div className="glass-gold fixed bottom-0 left-0 w-full p-6 pb-12 z-[40] border-t-2 border-[#ff66aa]/40">
                        <div className="flex overflow-x-auto gap-6 px-4 no-scrollbar">
                            {Object.entries(resources.units).map(([key, info]) => (
                                <button key={key} onClick={() => setUI(p => ({...p, selected: key, upgrade: null}))} className={`relative p-6 min-w-[120px] rounded-[3rem] border-2 transition-all ${ui.selected === key ? 'bg-[#ff66aa]/30 border-[#ff66aa] -translate-y-4 scale-110' : 'bg-white/5 opacity-60'}`}>
                                    <span className="text-6xl">{info.icon}</span>
                                    <p className="text-sm font-black text-amber-400 mt-2 font-mono">{info.cost}</p>
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
