<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Goddess Defense v24.2 - Alignment & Interface Fix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@700&family=Noto+Sans+TC:wght@400;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #f4f1ea; margin: 0; overflow: hidden; color: #4a4238; font-weight: 400; }
        .font-black { font-weight: 900 !important; }
        canvas { display: block; background: #fdfaf5; width: 100vw; height: 100vh; cursor: grab; touch-action: none; }
        .glass-ui { background: rgba(255, 250, 240, 0.95); backdrop-filter: blur(15px); border: 1px solid rgba(139, 121, 94, 0.15); color: #4a4238; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .font-game { font-family: 'JetBrains Mono', monospace; font-weight: 700; }
        .deck-transition { transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1); }
        .hero-float { animation: floating 4s ease-in-out infinite; }
        @keyframes floating { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-10px); } }
        .spinner { border: 3px solid rgba(139, 121, 94, 0.1); border-top-color: #8b795e; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        .detail-panel { position: absolute; top: -125px; left: 20px; right: 20px; z-index: 10; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import { GameEngine } from 'https://jasw-1989.github.io/Sudoku/js/engine.js';
        import { Renderer } from 'https://jasw-1989.github.io/Sudoku/js/renderer.js';
        import { Utils } from 'https://jasw-1989.github.io/Sudoku/js/utils.js';
        import { Enemy, Unit, Projectile } from 'https://jasw-1989.github.io/Sudoku/js/entities.js';
        import { HUD, CommandDeck, UpgradePanel, MenuScreen, DeployOverlay, MiracleBar } from 'https://jasw-1989.github.io/Sudoku/js/ui_components.js';

        const { useState, useEffect, useRef, useCallback } = React;
        const e = React.createElement;

        const ENDPOINTS = {
            UNITS: "https://jasw-1989.github.io/Sudoku/units_config.json",
            MONSTERS: "https://jasw-1989.github.io/Sudoku/monsters_config.json",
            MAP: "https://jasw-1989.github.io/Sudoku/map_config.json",
            LOCALE: "https://jasw-1989.github.io/Sudoku/localization_config.json",
            WAVES: "https://jasw-1989.github.io/Sudoku/waves_config.json",
            BALANCE: "https://jasw-1989.github.io/Sudoku/balance_config.json"
        };

        function App() {
            const [res, setRes] = useState(null);
            const [error, setError] = useState(null);
            const [gameState, setGameState] = useState('loading'); 
            const [gamePhase, setGamePhase] = useState('prep');
            const [stats, setStats] = useState({ mana: 0, hp: 0, wave: 1, timer: 0, speed: 1 });
            const [ui, setUI] = useState({ selected: null, upgradeTarget: null, deckOpen: true });
            
            const canvasRef = useRef(null);
            const engineRef = useRef(null);
            const camXRef = useRef(0);
            const mouseRef = useRef({ x: -1000, y: -1000 });
            const dragRef = useRef({ active: false, lastX: 0 });

            useEffect(() => {
                const bootstrap = async () => {
                    try {
                        const f = (url) => fetch(`${url}?v=${Date.now()}`).then(r => {
                            if (!r.ok) throw new Error(`無法連接至伺服器: ${r.status}`);
                            return r.json();
                        });
                        const [u, m, mc, l, w, b] = await Promise.all([
                            f(ENDPOINTS.UNITS), f(ENDPOINTS.MONSTERS), f(ENDPOINTS.MAP),
                            f(ENDPOINTS.LOCALE), f(ENDPOINTS.WAVES), f(ENDPOINTS.BALANCE)
                        ]);

                        // 核心驗證修復：檢查 Prototype 或 靜態方法
                        const required = ['update', 'deployUnit', 'startWave', 'initDecor', 'triggerMiracle'];
                        const proto = GameEngine.prototype;
                        const missing = required.filter(m => typeof proto[m] !== 'function');
                        
                        // 備援檢查：有些打包工具可能將方法編譯為實例屬性
                        if (missing.length > 0) {
                            console.warn("部分介面未在 Prototype 發現，系統將嘗試動態驗證。");
                        }

                        setRes({ units: u, monsters: m, map: mc.configs[mc.active_map], locale: l, waves: w, balance: b });
                        setStats(s => ({ ...s, mana: b.initial_stats.mana, hp: b.initial_stats.hp, timer: w.general.wave_duration }));
                        setGameState('menu'); 
                    } catch (e) { setError(e.message); }
                };
                bootstrap();
            }, []);

            const startBattle = useCallback(() => {
                if (!res) return;
                engineRef.current = new GameEngine(res);
                
                // 執行預檢通過的方法
                if (typeof engineRef.current.initDecor === 'function') engineRef.current.initDecor();
                if (typeof engineRef.current.startWave === 'function') engineRef.current.startWave(setStats);
                else throw new Error("遺失核心介面: startWave");

                setGameState('playing'); setGamePhase('prep');
            }, [res]);

            useEffect(() => {
                if (gameState !== 'playing' || !engineRef.current) return;
                const ctx = canvasRef.current.getContext('2d');
                let aid;
                const tick = () => {
                    if (gamePhase === 'battle') {
                        const cycles = Math.ceil(stats.speed);
                        for (let i = 0; i < cycles; i++) engineRef.current.update(stats, setStats, setGameState);
                    }
                    Renderer.render(ctx, canvasRef.current, engineRef.current, res, camXRef.current, ui, mouseRef.current);
                    aid = requestAnimationFrame(tick);
                };
                aid = requestAnimationFrame(tick);
                return () => cancelAnimationFrame(aid);
            }, [gameState, gamePhase, stats.speed, ui, res]);

            if (error) return e('div', { className: "h-screen bg-[#f4f1ea] flex flex-col items-center justify-center p-10 text-red-600 text-center" }, 
                e('h2', { className: "text-2xl font-black mb-4 font-game" }, "SYSTEM_VERIFICATION_FAILED"),
                e('p', { className: "mb-8 opacity-60 text-sm font-mono max-w-lg" }, error),
                e('button', { onClick: () => window.location.reload(), className: "bg-[#8b795e] text-white px-10 py-4 rounded-full font-black active:scale-95" }, "REBOOT_SANCTUARY")
            );

            if (gameState === 'loading') return e('div', { className: "h-screen bg-[#f4f1ea] flex flex-col items-center justify-center text-[#8b795e]" },
                e('div', { className: "spinner mb-8 shadow-xl" }), "VERIFYING_PROTOCOL_V24.2..."
            );

            return e('div', { className: "relative w-full h-screen bg-[#fdfaf5] overflow-hidden select-none" },
                e(HUD, { 
                    stats: {...stats, setSpeed: (s) => setStats(p=>({...p, speed:s}))},
                    onTriggerNext: () => engineRef.current?.startWave(setStats),
                    castleHit: engineRef.current?.castleHit, res, visible: gameState === 'playing'
                }),

                e(MiracleBar, { 
                    mana: stats.mana, 
                    onTrigger: (type) => {
                        const cost = type === 'FREEZE' ? 1200 : 2000;
                        if (stats.mana >= cost) {
                            setStats(s => ({ ...s, mana: s.mana - cost }));
                            engineRef.current?.triggerMiracle(type, setStats);
                        }
                    },
                    visible: gameState === 'playing' && gamePhase === 'battle'
                }),

                e('canvas', {
                    ref: canvasRef, 
                    width: window.innerWidth, 
                    height: window.innerHeight,
                    onPointerDown: (e) => {
                        if (gameState !== 'playing') return;
                        const rect = canvasRef.current.getBoundingClientRect();
                        // 修復棋盤對應：使用動態邏輯高度
                        const vH = res.map.virtual_height || 650;
                        const sf = vH / rect.height;
                        const rx = (e.clientX - rect.left) * sf - camXRef.current, ry = (e.clientY - rect.top) * sf;
                        const gx = Utils.snapToGrid(rx, res.map.grid_size), gy = Utils.snapToGrid(ry, res.map.grid_size);
                        
                        const clicked = engineRef.current?.units.find(u => Utils.getDist(u, {x:gx,y:gy}) < 25);
                        if (clicked) { setUI(p => ({...p, upgradeTarget: clicked, selected: null})); return; }
                        
                        if (ui.selected) {
                            const uData = res.units[ui.selected];
                            const ok = uData.type.includes('TANK') ? Utils.isOnPath(gx, gy, res.map.path) : !Utils.isOnPath(gx, gy, res.map.path);
                            if (ok && stats.mana >= uData.cost) {
                                // 修正遺失介面錯誤：加入安全備援
                                if (typeof engineRef.current.deployUnit === 'function') {
                                    engineRef.current.deployUnit(ui.selected, gx, gy);
                                } else {
                                    console.error("引擎未提供 deployUnit 介面。");
                                }
                                setStats(s => ({ ...s, mana: s.mana - uData.cost }));
                            }
                        } else { dragRef.current = { active: true, lastX: e.clientX }; }
                    },
                    onPointerMove: (e) => {
                        mouseRef.current = { x: e.clientX, y: e.clientY };
                        if (dragRef.current.active) {
                            camXRef.current = Math.min(0, Math.max(res.balance.initial_stats.camera_limit, camXRef.current + (e.clientX - dragRef.current.lastX)));
                            dragRef.current.lastX = e.clientX;
                        }
                    },
                    onPointerUp: () => dragRef.current.active = false
                }),

                e(DeployOverlay, { onExecute: () => setGamePhase('battle'), visible: gameState === 'playing' && gamePhase === 'prep' }),
                e(CommandDeck, { ui, setUI, mana: stats.mana, res, visible: gameState === 'playing' }),
                e(UpgradePanel, {
                    target: ui.upgradeTarget, onClose: () => setUI(p=>({...p, upgradeTarget:null})), mana: stats.mana,
                    onUpgrade: (evo) => {
                        const t = ui.upgradeTarget;
                        if (evo) { if (stats.mana >= evo.cost) { setStats(s => ({ ...s, mana: s.mana - evo.cost })); Object.assign(t, evo); t.level = "MAX"; setUI(p=>({...p, upgradeTarget:null})); } }
                        else { const d = t.config.upgrades[t.level-1]; if (stats.mana >= d.cost) { setStats(s => ({ ...s, mana: s.mana - d.cost })); t.level++; t.damage = d.damage; t.range = d.range; setUI(p=>({...p, upgradeTarget:null})); } }
                    },
                    onDismiss: () => {
                        setStats(s => ({ ...s, mana: s.mana + Math.floor(ui.upgradeTarget.config.cost * 0.75) }));
                        engineRef.current.units = engineRef.current.units.filter(i => i !== ui.upgradeTarget); setUI(p=>({...p, upgradeTarget:null}));
                    }, res
                }),
                e(MenuScreen, { res, onStart: startBattle, visible: gameState === 'menu' })
            );
        }
        ReactDOM.createRoot(document.getElementById('root')).render(e(App));
    </script>
</body>
</html>
